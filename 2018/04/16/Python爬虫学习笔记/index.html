<!DOCTYPE html>


  <html class="dark page-post">


<head>
  <meta charset="utf-8">
  
  <title>Python爬虫学习笔记 | 猪小张的温暖被窝</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术,Python," />
  

  <meta name="description" content="1. URLlib21urlopen(url, data, timeout)   第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT    2. GET#####是直接以链接形式访问，链接中包含了所有的">
<meta name="keywords" content="技术,Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python爬虫学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/04/16/Python爬虫学习笔记/index.html">
<meta property="og:site_name" content="猪小张的温暖被窝">
<meta property="og:description" content="1. URLlib21urlopen(url, data, timeout)   第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT    2. GET#####是直接以链接形式访问，链接中包含了所有的">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-05-27T07:57:37.817Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python爬虫学习笔记">
<meta name="twitter:description" content="1. URLlib21urlopen(url, data, timeout)   第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT    2. GET#####是直接以链接形式访问，链接中包含了所有的">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-URLlib2"><span class="toc-text">1. URLlib2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-GET"><span class="toc-text">2. GET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-POST"><span class="toc-text">3. POST</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-设置headers"><span class="toc-text">4. 设置headers</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#另外headers的一些属性"><span class="toc-text">另外headers的一些属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-设置Proxy-代理"><span class="toc-text">5. 设置Proxy(代理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置Timeout"><span class="toc-text">设置Timeout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-HTTP的-PUT-和-DELETE-方法"><span class="toc-text">6. HTTP的 PUT 和 DELETE 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-DebugLog"><span class="toc-text">7. DebugLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-URLError网络异常捕捉"><span class="toc-text">8. URLError网络异常捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPError"><span class="toc-text">HTTPError</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Cookies"><span class="toc-text">9. Cookies</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Opener"><span class="toc-text">Opener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookielib"><span class="toc-text">Cookielib</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#re-match-pattern-string-flags"><span class="toc-text">re.match(pattern,string[,flags])</span></a></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-Python爬虫学习笔记" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Python爬虫学习笔记</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.04.16</span>
      </span>

      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/日志/">日志</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://ohmydamncode.github.io/2018/04/16/Python爬虫学习笔记/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="1-URLlib2"><a href="#1-URLlib2" class="headerlink" title="1. URLlib2"></a>1. URLlib2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlopen(url, data, timeout)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</li>
<li>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</li>
</ul>
</blockquote>
<hr>
<h2 id="2-GET"><a href="#2-GET" class="headerlink" title="2. GET"></a>2. GET</h2><p>#####是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">values = &#123;&quot;username&quot;:&quot;username&quot;,&quot;password&quot;:&quot;password&quot;&#125;</span><br><span class="line">data = urllib.urlencode(values)</span><br><span class="line">url = &quot;https://mail.qq.com&quot;</span><br><span class="line">urlx = url+&quot;?&quot;+data</span><br><span class="line">request = urllib2.Request(urlx)</span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print response.read()</span><br><span class="line">print urlx</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>引入urllib库，利用urllib的urlencode方法将字典编码</p>
</blockquote>
<hr>
<h2 id="3-POST"><a href="#3-POST" class="headerlink" title="3. POST"></a>3. POST</h2><p>#####隐式传输参数，不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">values = &#123;&quot;username&quot;:&quot;username&quot;,&quot;password&quot;:&quot;password&quot;&#125;</span><br><span class="line">data = urllib.urlencode(values)</span><br><span class="line">url = &quot;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;</span><br><span class="line">request = urllib2.Request(url,data)</span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print response.read()</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="4-设置headers"><a href="#4-设置headers" class="headerlink" title="4. 设置headers"></a>4. 设置headers</h2><p>　　有些网站不允许程序（爬虫）用上面的方式直接访问，站点根本不会响应。为了完全模拟浏览器的工作，需要设置 headers 的一些属性。</p>
<ul>
<li>使用 Chrome 浏览器随便打开一个网页，点击一项请求操作。</li>
<li>按F12进入开发者模式，选择 Network，选择 Name 列表中的第一项请求，可以看到 Request URL，Response Headers，Request Headers 等内容。</li>
<li>观察 Request Headers，可以看到这个头中包含了许多内容，有文件编码，压缩方式，User-Agent 等等。</li>
</ul>
<p>　　其中，User-Agent 就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在 Request Headers 中设置 User-Agent。格式如下。<br><strong> User-Agent可以从Request Headers的User-Agent复制过来</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">url = &apos;http://https://www.baidu.com/&apos;</span><br><span class="line">user_agent = &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64)&apos;</span><br><span class="line">values = &#123;&apos;username&apos;:&apos;username&apos;,&apos;password&apos;:&apos;password&apos;&#125;</span><br><span class="line">headers = &#123;&apos;User-Agent&apos;:user_agent&#125;</span><br><span class="line">data = urllib.urlencode(values)</span><br><span class="line">request = urllib2.Request(url, data, headers)</span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print response.read()</span><br></pre></td></tr></table></figure>
<p>在对付防盗链时，服务器会识别 headers 中的 Referer 是不是它自己，如果不是，有的服务器不会响应，所以一般还应在 headers 中加入 referer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64)&apos;,&apos;Referer&apos;:&apos;https://www.baidu.com/&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h4 id="另外headers的一些属性"><a href="#另外headers的一些属性" class="headerlink" title="另外headers的一些属性"></a>另外headers的一些属性</h4><blockquote>
<ul>
<li>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求</li>
<li>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。</li>
<li>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用</li>
<li>application/json ： 在 JSON RPC 调用时使用</li>
<li>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用</li>
<li>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h2 id="5-设置Proxy-代理"><a href="#5-设置Proxy-代理" class="headerlink" title="5. 设置Proxy(代理)"></a>5. 设置Proxy(代理)</h2><p>　　urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。如果一个网站通过检测IP访问次数，来限制访问，那么显然程序就会失效。所以可以通过设置一些代理服务器来帮助我们做工作，每隔一段时间换一个代理，让网站彻底眼瞎懵逼。<br><strong>代理的设置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enable_proxy = True</span><br><span class="line">proxy_handler = urllib2.ProxyHandler(&#123;&apos;https&apos;:&apos;https://mail.qq.com:8080&apos;&#125;)</span><br><span class="line">null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)</span><br><span class="line">if enable_proxy:</span><br><span class="line">	opener = urllib2.build_opnener(proxy_handler)</span><br><span class="line">else:</span><br><span class="line">	opener = urllib2.build_opnener(null_proxy_handler)</span><br><span class="line">urllib2.install_opener(opener)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="设置Timeout"><a href="#设置Timeout" class="headerlink" title="设置Timeout"></a>设置Timeout</h2><p>urlopen 方法第三个参数就是 timeout，为解决一些网站响应过慢，可以设置等待多久超时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=urllib2.urlopen(url, data, timeout)</span><br></pre></td></tr></table></figure></p>
<p>如果第二个参数data为空，要特别指定是timeout是多少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=urllib2.urlopen(url, timeout=20)</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-HTTP的-PUT-和-DELETE-方法"><a href="#6-HTTP的-PUT-和-DELETE-方法" class="headerlink" title="6. HTTP的 PUT 和 DELETE 方法"></a>6. HTTP的 PUT 和 DELETE 方法</h2><p>HTTP协议有6中请求方法：get，post，head，put，delete，options</p>
<blockquote>
<ul>
<li>PUT：较少见，HTML表单不支持。和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</li>
<li>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</li>
</ul>
</blockquote>
<p><strong>使用 HTTP PUT 和 DELETE ，可以调用request的get_method方法，使 urllib2 发出 PUT 或 DELETE 请求。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">request = urllib2.Request(url, data)</span><br><span class="line">request.get_method = lambda: &apos;PUT&apos; # or &apos;DELETE&apos;</span><br><span class="line">response = urllib2.urlopen(request)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="7-DebugLog"><a href="#7-DebugLog" class="headerlink" title="7. DebugLog"></a>7. DebugLog</h2><p><strong>可以通过 DebugLog 查看收发包的内容，方便调试。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">httpHandler = urllib2.HTTPHandler(debuglevel=1)</span><br><span class="line">httpsHandler = urllib2.HTTPSHandler(debuglevel=1)</span><br><span class="line">opener = urllib2.build_opener(httpHandler, httpsHandler)</span><br><span class="line">urllib2.install_opener(opener)</span><br><span class="line">response = urllib2.urlopen(&apos;http://www.baidu.com&apos;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="8-URLError网络异常捕捉"><a href="#8-URLError网络异常捕捉" class="headerlink" title="8. URLError网络异常捕捉"></a>8. URLError网络异常捕捉</h2><ul>
<li>####URLError<br>产生网络异常的原因：<ul>
<li>网络无连接</li>
<li>找不到指定服务器</li>
<li>服务器不存在</li>
</ul>
</li>
</ul>
<p><strong>一般使用try-except语句进行捕捉：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">request = urllib2.Request(&apos;http://xxxxx.com&apos;)</span><br><span class="line">try:</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">except urllib2.URLError, e:</span><br><span class="line">	print e.reason</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>类似Java中的try-catch异常捕捉</p>
</blockquote>
<p> 程序运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Errno 11004] getaddrinfo failed</span><br></pre></td></tr></table></figure></p>
<p>错误代号11004，原因是 getaddrinfo failed</p>
<ul>
<li><h4 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h4><p>　　HTTPError 是 URLError 的子类，使用 urlopen 发出一个请求时，服务器上会应答一个 response 对象，其中包含一个“状态码”。对无法处理的对象，urlopen 会产生一个 HTTPError，对应相应的状态码。HTTP 状态码反映了响应的状态。</p>
<p><strong>下面将状态码归结如下：</strong></p>
<blockquote>
<ul>
<li>100：继续<br>客户端应当继续发送请求。如果请求已经完成，忽略这个响应。</li>
<li>101： 转换协议<br>在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。</li>
<li>102：继续处理<br>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</li>
<li>200：请求成功<br>处理方式：获得响应的内容，进行处理</li>
<li>201：请求完成，创建新资源。<br>新创建资源的URL可在响应的实体中得到处理方式：<strong>爬虫中不会遇到</strong></li>
<li>202：请求被接受，但处理尚未完成<br>处理方式：阻塞等待</li>
<li>204：服务器端已经实现了请求，但是没有返回新的信息。<br>如果客户是用户代理，则无须为此更新自身的文档视图。处理方式：丢弃</li>
<li>300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。<br>处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃</li>
<li>301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源<br>处理方式：重定向到分配的URL</li>
<li>302：请求到的资源在一个不同的URL处临时保存<br>处理方式：重定向到临时的URL</li>
<li>304：请求的资源未更新<br>处理方式：丢弃</li>
<li>400：非法请求<br>处理方式：丢弃</li>
<li>401：未授权<br>处理方式：丢弃</li>
<li>403：禁止<br>处理方式：丢弃</li>
<li>404：没有找到<br>处理方式：丢弃</li>
<li>500：服务器内部错误<br>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</li>
<li>501：服务器无法识别<br>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</li>
<li>502：错误网关<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li>
<li>503：服务出错<br>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</li>
</ul>
</blockquote>
<p>HTTPError 实例化后会产生一个 code 属性，这就是服务器发送的状态码。<br>urllib2 能够自动处理重定向，也就是<strong>3</strong>开头的代号可以被处理；100-299 范围的号码表示成功，所以我们只能看到 400-599 的错误号码。<br><strong>下面写一个例子来感受一下，我们打印了reason属性，这是它的父类URLError的属性。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">request = urllib2.Request(&apos;http://www.baidu.com&apos;)</span><br><span class="line">try:</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">except urllib2.HTTPError, e:</span><br><span class="line">	print e.code</span><br><span class="line">	print e.reason</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们知道，URLError是HTTPError的父类，根据编程经验，父类的异常应当写到子类异常的后面，如果子类捕获不到，还可以捕获父类的异常。上述代码except部分可以这么改写：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">except urllib2.HTTPError, e:</span><br><span class="line">	print e.code</span><br><span class="line">#如果捕获到了HTTPError，则输出code，不会再处理URLError异常</span><br><span class="line">except urllib2.URLError, e:</span><br><span class="line">	print e.reason</span><br><span class="line">else:</span><br><span class="line">	print &apos;OK&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者可以使用 hasattr 属性提前对属性进行判断：</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">request = urllib2.Request(&apos;http://www.baidu.com&apos;)</span><br><span class="line">try:</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">except urllib2.HTTPError, e:</span><br><span class="line">	if hasattr(e,&apos;reason&apos;):</span><br><span class="line">		print e.reason</span><br><span class="line">	else:</span><br><span class="line">	print &apos;OK&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="9-Cookies"><a href="#9-Cookies" class="headerlink" title="9. Cookies"></a>9. Cookies</h2><p>Cookie，网站储存在用户本地上的数据（通常经过加密）。<br>对于需要登录的网页，可以利用Urllib2库保存登录的Cookie，然后再抓取其他页面。</p>
<ul>
<li><h4 id="Opener"><a href="#Opener" class="headerlink" title="Opener"></a>Opener</h4>　　当我们获取一个URL时我们就使用了一个 <code>opener</code> (一个urllib2.OpenerDirector的实例)。在前面，使用的都是默认的opener，也就是urlopen，传入的参数仅仅是<code>url，data，timeout</code>。<br>　　如果需要用到 Cookie，只用这个 opener 是不能达到目的的，所以我们需要创建更一般的 opener 来实现对Cookie的设置。</li>
<li><h4 id="Cookielib"><a href="#Cookielib" class="headerlink" title="Cookielib"></a>Cookielib</h4>　　<code>cookielib</code>模块提供可存储 cookie 的对象，便于与<code>urllib2</code>模块配合使用来访问 Internet 资源。Cookielib 模块非常强大，我们可以利用本模块的 <code>CookieJar</code>类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有<code>CookieJar</code>、<code>FileCookieJar</code>、<code>MozillaCookieJar</code>、<code>LWPCookieJar</code>。<br>　　它们的关系：CookieJar —-派生—-&gt; FileCookieJar  —-派生—–&gt;MozillaCookieJar 和 LWPCookieJar<br><strong>获取cookie保存到变量</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">import cookielib</span><br><span class="line">#声明一个CookieJar对象实例来保存cookie</span><br><span class="line">cookie = cookielib.CookieJar()</span><br><span class="line">#利用URLlib库的HTTPCookieProcessor对象来创建cookie处理器</span><br><span class="line">handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">#通过handler来构造opener</span><br><span class="line">opener = urllib2.build_opener(handler)</span><br><span class="line">#此处open方法同URLlib2的urlopen方法相同，也可以传入request</span><br><span class="line">response = opener.open(&apos;http://www.baidu.com&apos;)</span><br><span class="line">for item in cookie:</span><br><span class="line">	print &apos;name = &apos;+item.name</span><br><span class="line">	print &apos;value = &apos;+item.value</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>上面的方法将 cookie 保存到了 cookie 变量中。如果想将 cookie 保存到文件中，就需要用到<code>FileCookieJar</code>对象。这里使用它的子类<code>MozillaCookieJar</code>来保存 cookie.</p>
</blockquote>
<pre><code>**将cookie保存到文件**
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">import cookielib</span><br><span class="line">#将cookie保存到文件</span><br><span class="line">file = &apos;cookie.txt&apos;</span><br><span class="line">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span><br><span class="line">cookie = cookielib.MozillaCookieJar(file)</span><br><span class="line">handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib2.build_opener(handler)</span><br><span class="line">response = opener.open(&apos;http://www.baidu.com&apos;)</span><br><span class="line">#保存cookie到文件</span><br><span class="line">cookie.save(ignore_discard = True,ignore_expires = True)</span><br></pre></td></tr></table></figure>
</code></pre><p><em>save方法的两个参数官方解释：</em></p>
<blockquote>
<p>*ignore_discard: save even cookies set to be discarded.<br>ignore_expires: save even cookies that have expired.The file is overwritten if it already exists</p>
</blockquote>
<pre><code>ignore_discard的意思是即使cookies将被丢弃也将它保存下来，ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入.*

**从文件获取cookie并访问网页**
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">import cookielib</span><br><span class="line">#创建MozillaCookieJar实例对象</span><br><span class="line">file = &apos;cookie.txt&apos;</span><br><span class="line">cookie = cookielib.MozillaCookieJar(file)</span><br><span class="line">#从文件中读取cookie内容到变量</span><br><span class="line">cookie.load(file,ignore_discard = True,ignore_expires = True)</span><br><span class="line">request = urllib2.Request(&apos;http://www.baidu.com&apos;)</span><br><span class="line">handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib2.build_opener(handler)</span><br><span class="line">response = opener.open(request)</span><br><span class="line">print response.read()</span><br></pre></td></tr></table></figure>
<pre><code>**利用cookie模拟网站登陆**
&gt;创建一个带有 cookie 的 operner，在访问登陆URL时，将登陆后的 cookie 保存下来，然后利用这个 cookie 去访问其他网址

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">import cookielib</span><br><span class="line">#利用cookie模拟网站登陆</span><br><span class="line">file = &apos;mycookie.txt&apos;</span><br><span class="line">cookie = cookielib.MozillaCookieJar(file)</span><br><span class="line">handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib2.build_opener(handler)</span><br><span class="line">data = urllib.urlencode(&#123;&apos;username&apos;:&apos;18587175931&apos;,&apos;password&apos;:&apos;shx199484007&apos;&#125;)</span><br><span class="line">user_agent = &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36&apos;</span><br><span class="line">referer=&apos;https://passport.csdn.net/account/login&apos;</span><br><span class="line">headers = &#123;&apos;User-Agent&apos;:user_agent,&apos;Referer&apos;:referer,&apos;Connection&apos;:&apos;keep-alive&apos;&#125;</span><br><span class="line">loginurl = &apos;https://passport.csdn.net/account/login&apos;</span><br><span class="line">request1 = urllib2.Request(loginurl,data,headers)</span><br><span class="line">try: </span><br><span class="line">	response1 = opener.open(request1)</span><br><span class="line">except urllib2.URLError as e:</span><br><span class="line">	print e.code+&apos;:&apos;+e,reason</span><br><span class="line">cookie.save(ignore_discard = True,ignore_expires = True)</span><br><span class="line">#利用cookie请求访问另一个网址</span><br><span class="line">infourl = &apos;https://bbs.csdn.net/forums/Service&apos;</span><br><span class="line">request2 = urllib2.Request(infourl,headers=headers)</span><br><span class="line">response2 = opener.open(request2)</span><br><span class="line">print response2.read()</span><br></pre></td></tr></table></figure>
</code></pre><hr>
<p>##10. 正则表达式——re模块<br>Python自带的re模块提供对正则表达式的支持。该模块主要方法有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#创建pattern对象</span><br><span class="line">pattern = re.compile(string[,flag])</span><br><span class="line">#匹配所用函数</span><br><span class="line">re.match(pattern,,string[,flags])</span><br><span class="line">re.search(pattern,string[,flags])</span><br><span class="line">re.split(pattern,string[,maxsplit])</span><br><span class="line">re.findall(pattern,string[,flags])</span><br><span class="line">re.finditer(pattern,string[,flags])</span><br><span class="line">re.sub(pattern,repl,string[,count])</span><br><span class="line">re.subn(pattern,repl,string[,count])</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。如果在pattern生成时已经指明flags的模式，则在方法中可以省略。</p>
</blockquote>
<p><strong>匹配模式可选值</strong></p>
<blockquote>
<ul>
<li>re.I (全拼：IGNORECASE): 忽略大小写</li>
<li>re.M (全拼：MULTILINE): 多行模式，改变’^’和’$’的行为</li>
<li>re.S (全拼：DOTALL): 点任意匹配模式，改变’.’的行为</li>
<li>re.L (全拼：LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定</li>
<li>re.U (全拼：UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性</li>
<li>re.X (全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</li>
</ul>
</blockquote>
<ul>
<li><h4 id="re-match-pattern-string-flags"><a href="#re-match-pattern-string-flags" class="headerlink" title="re.match(pattern,string[,flags])"></a>re.match(pattern,string[,flags])</h4>这个方法将会从字符串的开头开始匹配pattern，遇到无法匹配的字符或匹配未结束已经到达string的末尾，返回None，表示匹配失败。<strong><em>若匹配pattern成功则立即终止匹配</em></strong>。<br><strong>例：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">#将正则表达式编译成Pattern对象，hello前面的r意思是“原生字符串”</span><br><span class="line">pattern = re.compile(r&apos;hello&apos;)</span><br><span class="line">result1 = re.match(pattern,&apos;hellokkil&apos;)</span><br><span class="line">result2 = re.match(pattern,&apos;hell o&apos;)</span><br><span class="line">result3 = re.match(pattern,&apos;hello MG&apos;)</span><br><span class="line">if result1:</span><br><span class="line">	print result1.group()</span><br><span class="line">else:</span><br><span class="line">	print &quot;1匹配失败！&quot;</span><br><span class="line">if result2:</span><br><span class="line">	print result2.group()</span><br><span class="line">else:</span><br><span class="line">	print &quot;2匹配失败！&quot;</span><br><span class="line">if result3:</span><br><span class="line">	print result3.group()</span><br><span class="line">else:</span><br><span class="line">	print &quot;3匹配失败！&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</strong></p>
<blockquote>
<ul>
<li>属性：<ul>
<li>1.string：匹配时使用的文本。</li>
<li>2.re：匹配时使用的Pattern对象。</li>
<li>3.pos：文本中正则表达式开始搜索的索引。</li>
<li>4.endpos：文本中正则表达式结束搜索的索引。</li>
<li>5.lastindex：最后一个被捕获的分组在文本中的索引。如果没有，将为None。</li>
<li>6.lastgroup：最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。</li>
</ul>
</li>
<li>方法：<ul>
<li>1.group([group1, …])：<br>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。</li>
<li>2.groups([default])：<br>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。</li>
<li>3.groupdict([default])：<br>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。</li>
<li>4.start([group])：<br>返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。</li>
<li>5.end([group])：<br>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。</li>
<li>6.span([group])：<br>返回(start(group), end(group))。</li>
<li>7.expand(template)：<br>将匹配到的分组代入template中然后返回。template中可以使用\id或\g、\g引用分组，但不能使用编号0。\id与\g是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符’0’，只能使用\g0。</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code>用一个例子感受一下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#匹配内容：单词+空格+任意字符</span><br><span class="line">m = re.match(r&apos;(\w+) (\w+)(?P&lt;sign&gt;.*)&apos;,&apos;hello world!&apos;)</span><br><span class="line">print &quot;m.string:&quot;,m.string</span><br><span class="line">print &quot;m.re:&quot;,m.re</span><br><span class="line">print &quot;m.pos:&quot;,m.pos</span><br><span class="line">print &quot;m.endpos:&quot;,m.endpos</span><br><span class="line">print &quot;m.lastindex:&quot;,m.lastindex</span><br><span class="line">print &quot;m.lastgroup:&quot;,m.lastgroup</span><br><span class="line">print &quot;m.group():&quot;,m.group()</span><br><span class="line">print &quot;m.group(1,2):&quot;,m.group(1,2)</span><br><span class="line">print &quot;m.groups():&quot;,m.groups()</span><br><span class="line">print &quot;m.groupdict():&quot;,m.groupdict()</span><br><span class="line">print &quot;m.start(2):&quot;,m.start(2)</span><br><span class="line">print &quot;m.end(2):&quot;,m.end(2)</span><br><span class="line">print &quot;m.span(2):&quot;,m.span(2)</span><br><span class="line">print &quot;m.expand(r&apos;\g\g\g&apos;):&quot;,m.expand(r&apos;\2\1\3&apos;)</span><br></pre></td></tr></table></figure>

输出结果：
![](http://p7kfdqgx5.bkt.clouddn.com/re-pic.jpg)
</code></pre><ul>
<li><p>####re.search(pattern,string[,flags])<br>search() 方法与 match() 方法类似，区别在于 match() 从 string 的开始位置匹配，search() 会扫描整个 string 查找匹配。match() 只有在0位置匹配成功的话才有返回，否则返回 None。同样，search() 方法的返回对象同样 match() 返回对象的方法和属性。</p>
</li>
<li><p>####re.spilt(pattern,string[,maxsplit])<br>按照匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;\d+&apos;)</span><br><span class="line">print re.split(pattern,&apos;one1two2three3four4&apos;)</span><br><span class="line">###返回值###</span><br><span class="line"># [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>####re.findall(pattern,string[,flags])<br>搜索string，以列表形式返回全部匹配的子串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;\d+&apos;)</span><br><span class="line">print re.split(pattern,&apos;one1two2three3four4&apos;)</span><br><span class="line">###返回值###</span><br><span class="line"># [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>####re.finditer(pattern,string[,flags])<br>搜索string，返回一个顺序访问每个匹配结果（Match对象）的迭代器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;\d+&apos;)</span><br><span class="line">for m in re.finditer(pattern,&apos;one1two2three3four4&apos;):</span><br><span class="line">    print m.group()</span><br><span class="line">###返回值###</span><br><span class="line">#1</span><br><span class="line">#2</span><br><span class="line">#3</span><br><span class="line">#4</span><br></pre></td></tr></table></figure>
</li>
<li><p>####re.sub(pattern, repl, string[, count])<br>使用 repl 替换 string 中每一个匹配的子串，并返回替换后的字符串。当 repl 是一个字符串时，可以使用 \id 或 \g 引用分组，但不能使用编号0。当 repl 是一个方法时，这个方法只接受Match对象，并返回一个字符串用于替换（返回的字符串中不能再引用分组）。<br>count用于指定最多替换次数，不指定时全部替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;(\w+) (\w+)&apos;)</span><br><span class="line">str = &apos;i say,hello world!&apos;</span><br><span class="line">print re.sub(pattern,r&apos;\2 \1&apos;,str)</span><br><span class="line">def func(m):</span><br><span class="line">	return m.group(1).title()+&apos; &apos;+m.group(2).title()</span><br><span class="line">print re.sub(pattern,func,str)</span><br><span class="line">###返回值###</span><br><span class="line"># say i, world hello!</span><br><span class="line"># I Say, Hello World!</span><br></pre></td></tr></table></figure>
</li>
<li><p>####re.subn(pattern, repl, string[, count])<br>返回 (sub(repl,string[,count])，替换次数)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(r&apos;(\w+) (\w+)&apos;)</span><br><span class="line">str = &apos;i say,hello world!&apos;</span><br><span class="line">print re.subn(pattern,r&apos;\2 \1&apos;,str)</span><br><span class="line">def func(m):</span><br><span class="line">	return m.group(1).title()+&apos; &apos;+m.group(2).title()</span><br><span class="line">print re.subn(pattern,func,str)</span><br><span class="line">###返回值###</span><br><span class="line">#(&apos;say i,world hello!&apos;, 2)</span><br><span class="line">#(&apos;I Say,Hello World!&apos;, 2)</span><br></pre></td></tr></table></figure></li>
</ul>

    
  </div>

  
      <div class="git"></div>
  

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="hide pull-left" href="/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2018/04/19/selenium-chromedriver执行报错解决方案/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://yoursite.com/2018/04/16/Python爬虫学习笔记/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    
    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
