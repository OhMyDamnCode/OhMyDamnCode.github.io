<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>Python爬虫学习笔记 | 猪小张的温暖被窝</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="技术,Python," />
  

  <meta name="description" content="目录 (Table of Contents) [TOC] URLlib21urlopen(url, data, timeout)   第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT    GET">
<meta name="keywords" content="技术,Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python爬虫学习笔记">
<meta property="og:url" content="http://yoursite.com/2018/04/16/abc/index.html">
<meta property="og:site_name" content="猪小张的温暖被窝">
<meta property="og:description" content="目录 (Table of Contents) [TOC] URLlib21urlopen(url, data, timeout)   第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT    GET">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-04-16T17:17:56.522Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python爬虫学习笔记">
<meta name="twitter:description" content="目录 (Table of Contents) [TOC] URLlib21urlopen(url, data, timeout)   第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。 第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT    GET">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbe6" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  

  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/category/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#URLlib2"><span class="toc-text">URLlib2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET"><span class="toc-text">GET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST"><span class="toc-text">POST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置headers"><span class="toc-text">设置headers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置Proxy-代理"><span class="toc-text">设置Proxy(代理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置Timeout"><span class="toc-text">设置Timeout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP的-PUT-和-DELETE-方法"><span class="toc-text">HTTP的 PUT 和 DELETE 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DebugLog"><span class="toc-text">DebugLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URLError网络异常捕捉"><span class="toc-text">URLError网络异常捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTPError"><span class="toc-text">HTTPError</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-abc" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">Python爬虫学习笔记</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2018.04.16</span>
      </span>

      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/日志/">日志</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://www.forsigner.com/2018/04/16/abc/#disqus_thread"></a>
        </span>
      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <p><strong>目录 (Table of Contents)</strong></p>
<p>[TOC]</p>
<h3 id="URLlib2"><a href="#URLlib2" class="headerlink" title="URLlib2"></a>URLlib2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urlopen(url, data, timeout)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。</li>
<li>第二三个参数是可以不传送的，data默认为空None，timeout默认为 socket._GLOBAL_DEFAULT_TIMEOUT</li>
</ul>
</blockquote>
<hr>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>　　是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">values = &#123;&quot;username&quot;:&quot;username&quot;,&quot;password&quot;:&quot;password&quot;&#125;</span><br><span class="line">data = urllib.urlencode(values)</span><br><span class="line">url = &quot;https://mail.qq.com&quot;</span><br><span class="line">urlx = url+&quot;?&quot;+data</span><br><span class="line">request = urllib2.Request(urlx)</span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print response.read()</span><br><span class="line">print urlx</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>引入urllib库，利用urllib的urlencode方法将字典编码</p>
</blockquote>
<hr>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>　　隐式传输参数，不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">values = &#123;&quot;username&quot;:&quot;username&quot;,&quot;password&quot;:&quot;password&quot;&#125;</span><br><span class="line">data = urllib.urlencode(values)</span><br><span class="line">url = &quot;http://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn&quot;</span><br><span class="line">request = urllib2.Request(url,data)</span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print response.read()</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="设置headers"><a href="#设置headers" class="headerlink" title="设置headers"></a>设置headers</h3><p>　　有些网站不允许程序（爬虫）用上面的方式直接访问，站点根本不会响应。为了完全模拟浏览器的工作，需要设置 headers 的一些属性。</p>
<ul>
<li>使用 Chrome 浏览器随便打开一个网页，点击一项请求操作。</li>
<li>按F12进入开发者模式，选择 Network，选择 Name 列表中的第一项请求，可以看到 Request URL，Response Headers，Request Headers 等内容。</li>
<li>观察 Request Headers，可以看到这个头中包含了许多内容，有文件编码，压缩方式，User-Agent 等等。</li>
</ul>
<p>　　其中，User-Agent 就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在 Request Headers 中设置 User-Agent。格式如下。</p>
<blockquote>
<p>User-Agent可以从Request Headers的User-Agent复制过来</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import urllib</span><br><span class="line">import urllib2</span><br><span class="line">url = &apos;http://https://www.baidu.com/&apos;</span><br><span class="line">user_agent = &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64)&apos;</span><br><span class="line">values = &#123;&apos;username&apos;:&apos;username&apos;,&apos;password&apos;:&apos;password&apos;&#125;</span><br><span class="line">headers = &#123;&apos;User-Agent&apos;:user_agent&#125;</span><br><span class="line">data = urllib.urlencode(values)</span><br><span class="line">request = urllib2.Request(url, data, headers)</span><br><span class="line">response = urllib2.urlopen(request)</span><br><span class="line">print response.read()</span><br></pre></td></tr></table></figure>
<p>　　在对付防盗链时，服务器会识别 headers 中的 Referer 是不是它自己，如果不是，有的服务器不会响应，所以一般还应在 headers 中加入 referer：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64)&apos;,&apos;Referer&apos;:&apos;https://www.baidu.com/&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>####另外headers的一些属性<blockquote>
<ul>
<li>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求</li>
<li>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。</li>
<li>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用</li>
<li>application/json ： 在 JSON RPC 调用时使用</li>
<li>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用</li>
<li>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</li>
</ul>
</blockquote>
</li>
</ul>
<hr>
<h3 id="设置Proxy-代理"><a href="#设置Proxy-代理" class="headerlink" title="设置Proxy(代理)"></a>设置Proxy(代理)</h3><p>　　urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。如果一个网站通过检测IP访问次数，来限制访问，那么显然程序就会失效。所以可以通过设置一些代理服务器来帮助我们做工作，每隔一段时间换一个代理，让网站彻底眼瞎懵逼。</p>
<blockquote>
<p>代理的设置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enable_proxy = True</span><br><span class="line">proxy_handler = urllib2.ProxyHandler(&#123;&apos;https&apos;:&apos;https://mail.qq.com:8080&apos;&#125;)</span><br><span class="line">null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)</span><br><span class="line">if enable_proxy:</span><br><span class="line">	opener = urllib2.build_opnener(proxy_handler)</span><br><span class="line">else:</span><br><span class="line">	opener = urllib2.build_opnener(null_proxy_handler)</span><br><span class="line">urllib2.install_opener(opener)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="设置Timeout"><a href="#设置Timeout" class="headerlink" title="设置Timeout"></a>设置Timeout</h3><p>　　urlopen 方法第三个参数就是 timeout，为解决一些网站响应过慢，可以设置等待多久超时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=urllib2.urlopen(url, data, timeout)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>如果第二个参数data为空，要特别指定是timeout是多少</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response=urllib2.urlopen(url, timeout=20)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="HTTP的-PUT-和-DELETE-方法"><a href="#HTTP的-PUT-和-DELETE-方法" class="headerlink" title="HTTP的 PUT 和 DELETE 方法"></a>HTTP的 PUT 和 DELETE 方法</h3><p>HTTP协议有6中请求方法：get，post，head，put，delete，options</p>
<blockquote>
<ul>
<li>PUT：较少见，HTML表单不支持。和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</li>
<li>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</li>
</ul>
</blockquote>
<p>　　使用 HTTP PUT 和 DELETE ，可以调用request的get_method方法，使 urllib2 发出 PUT 或 DELETE 请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">request = urllib2.Request(url, data)</span><br><span class="line">request.get_method = lambda: &apos;PUT&apos; # or &apos;DELETE&apos;</span><br><span class="line">response = urllib2.urlopen(request)</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="DebugLog"><a href="#DebugLog" class="headerlink" title="DebugLog"></a>DebugLog</h3><p>可以通过 DebugLog 查看收发包的内容，方便调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">httpHandler = urllib2.HTTPHandler(debuglevel=1)</span><br><span class="line">httpsHandler = urllib2.HTTPSHandler(debuglevel=1)</span><br><span class="line">opener = urllib2.build_opener(httpHandler, httpsHandler)</span><br><span class="line">urllib2.install_opener(opener)</span><br><span class="line">response = urllib2.urlopen(&apos;http://www.baidu.com&apos;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="URLError网络异常捕捉"><a href="#URLError网络异常捕捉" class="headerlink" title="URLError网络异常捕捉"></a>URLError网络异常捕捉</h3><ul>
<li><p>####URLError<br>产生网络异常的原因：</p>
<ul>
<li>网络无连接</li>
<li>找不到指定服务器</li>
<li>服务器不存在</li>
</ul>
<p>一般使用try-except语句进行捕捉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">request = urllib2.Request(&apos;http://xxxxx.com&apos;)</span><br><span class="line">try:</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">except urllib2.URLError, e:</span><br><span class="line">	print e.reason</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>类似Java中的try-catch异常捕捉</p>
</blockquote>
<p> 程序运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Errno 11004] getaddrinfo failed</span><br></pre></td></tr></table></figure></p>
<p>错误代号11004，原因是 getaddrinfo failed</p>
<ul>
<li><h4 id="HTTPError"><a href="#HTTPError" class="headerlink" title="HTTPError"></a>HTTPError</h4><p>　　HTTPError 是 URLError 的子类，使用 urlopen 发出一个请求时，服务器上会应答一个 response 对象，其中包含一个“状态码”。对无法处理的对象，urlopen 会产生一个 HTTPError，对应相应的状态码。HTTP 状态码反映了响应的状态。</p>
<p><strong>下面将状态码归结如下：</strong></p>
<blockquote>
<ul>
<li>100：继续<br>客户端应当继续发送请求。如果请求已经完成，忽略这个响应。</li>
<li>101： 转换协议<br>在发送完这个响应最后的空行后，服务器将会切换到在 Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。</li>
<li>102：继续处理<br>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</li>
<li>200：请求成功<br>处理方式：获得响应的内容，进行处理</li>
<li>201：请求完成，创建新资源。<br>新创建资源的URL可在响应的实体中得到处理方式：<strong>爬虫中不会遇到</strong></li>
<li>202：请求被接受，但处理尚未完成<br>处理方式：阻塞等待</li>
<li>204：服务器端已经实现了请求，但是没有返回新的信息。<br>如果客户是用户代理，则无须为此更新自身的文档视图。处理方式：丢弃</li>
<li>300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。<br>处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃</li>
<li>301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源<br>处理方式：重定向到分配的URL</li>
<li>302：请求到的资源在一个不同的URL处临时保存<br>处理方式：重定向到临时的URL</li>
<li>304：请求的资源未更新<br>处理方式：丢弃</li>
<li>400：非法请求<br>处理方式：丢弃</li>
<li>401：未授权<br>处理方式：丢弃</li>
<li>403：禁止<br>处理方式：丢弃</li>
<li>404：没有找到<br>处理方式：丢弃</li>
<li>500：服务器内部错误<br>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</li>
<li>501：服务器无法识别<br>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</li>
<li>502：错误网关<br>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li>
<li>503：服务出错<br>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</li>
</ul>
</blockquote>
<p>HTTPError 实例化后会产生一个 code 属性，这就是服务器发送的状态码。<br>urllib2 能够自动处理重定向，也就是<strong>3</strong>开头的代号可以被处理；100-299 范围的号码表示成功，所以我们只能看到 400-599 的错误号码。</p>
<blockquote>
<p>下面写一个例子来感受一下，我们打印了reason属性，这是它的父类URLError的属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">request = urllib2.Request(&apos;http://www.baidu.com&apos;)</span><br><span class="line">try:</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">except urllib2.HTTPError, e:</span><br><span class="line">	print e.code</span><br><span class="line">	print e.reason</span><br></pre></td></tr></table></figure>
<blockquote>
<p>　　 我们知道，URLError是HTTPError的父类，根据编程经验，父类的异常应当写到子类异常的后面，如果子类捕获不到，还可以捕获父类的异常。上述代码except部分可以这么改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">except urllib2.HTTPError, e:</span><br><span class="line">	print e.code</span><br><span class="line">#如果捕获到了HTTPError，则输出code，不会再处理URLError异常</span><br><span class="line">except urllib2.URLError, e:</span><br><span class="line">	print e.reason</span><br><span class="line">else:</span><br><span class="line">	print &apos;OK&apos;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>或者可以使用 hasattr 属性提前对属性进行判断：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import urllib2</span><br><span class="line">request = urllib2.Request(&apos;http://www.baidu.com&apos;)</span><br><span class="line">try:</span><br><span class="line">	response = urllib2.urlopen(request)</span><br><span class="line">except urllib2.HTTPError, e:</span><br><span class="line">	if hasattr(e,&apos;reason&apos;):</span><br><span class="line">		print e.reason</span><br><span class="line">	else:</span><br><span class="line">	print &apos;OK&apos;</span><br></pre></td></tr></table></figure></li>
</ul>

    
  </div>

  
      <div class="git"></div>
  

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持forsigner</div>
        <ul>
        
          <li class="item">
            <span>微信扫一扫</span>
            <img src="/images/qr-wechat.png" alt="">
          </li>
        
          <li class="item">
            <span>支付宝扫一扫</span>
            <img src="/images/qr-alipay.png" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2018/04/14/abc/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="hide pull-right" href="/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/category/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'forsigner';
    
    var disqus_url = 'http://yoursite.com/2018/04/16/abc/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//forsigner.disqus.com/count.js" async></script>



    
    

    
    

    

    
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
